---
description: 掌握并发控制的基本概念，并发控制与实现技术，了解封锁技术的实施等
---

# 第九章\~并发控制

{% hint style="info" %}
<mark style="color:red;">交叉并发方式</mark>和<mark style="color:purple;">同时并发方式</mark>
{% endhint %}

## 9.1 并发控制概述 <a href="#9.1-overview-of-concurrency-control" id="9.1-overview-of-concurrency-control"></a>

> <mark style="background-color:red;">事务是并发控制的基本单位</mark>，保证事务的 ACID 特性是事务处理的重要任务，而破坏事务 ACID 特性的原因之一就是多个事务并发操作造成的。为了保证事务的隔离性和一致性，数据库管理系统需要对并发操作进行正确调度。这些就是数据库管理系统中并发控制机制的责任

三类产生数据不一致的原因：

* 丢失修改
* 不可重复读
* 读脏数据

主要原因是并发操作破坏了事务的隔离性，<mark style="color:purple;">并发控制机制</mark>就是要<mark style="background-color:red;">用正确的方式调度并发操作，使一个用户事务的执行不受其它事务的干扰</mark>，从而避免造成数据的不一致性

并发控制的主要技术又有封锁、时间戳、乐观控制法、多版本控制法等

## 9.2 封锁 <a href="#9.2-blockade" id="9.2-blockade"></a>

封锁是并发控制的一个非常重要的技术

基本的封锁类型有两种：

<mark style="color:purple;">排他锁</mark>又称<mark style="color:red;">写锁(X 锁)</mark>

<mark style="color:purple;">共享锁</mark>又称<mark style="color:orange;">读锁(S 锁)</mark>

## 9.3 封锁协议 <a href="#9.3-blockade-agreement" id="9.3-blockade-agreement"></a>

规定申请 X 锁和 S 锁的时机、持续时间、释放时机的额规则称为<mark style="color:red;">封锁协议</mark>

### 9.3.1 一级封锁协议 <a href="#9.3.1" id="9.3.1"></a>

{% hint style="info" %}
事务 T 在修改数据 R 之前必须先对 R 加 X 锁，直到事务结束才释放
{% endhint %}

> 一级封锁协议只能解决不丢失修改，在事务开始时先加了 X 锁，其它事务无法读取其修改前的值

### 9.3.2 二级封锁协议 <a href="#9.3.2" id="9.3.2"></a>

{% hint style="info" %}
事务在一级封锁的基础上，要求读取数据 R 前必须先对 R 加 S 锁，读取完数据之后即可释放
{% endhint %}

> 二级封锁协议只能保存不读脏数据和不丢失修改，因为其它事务还是能在事务 T 第一次读取完数据后修改数据，导致事务 T 第二次读取数据的结果不一致

### 9.3.3 三级封锁协议 <a href="#9.3.3" id="9.3.3"></a>

{% hint style="info" %}
事务在一级封锁协议的基础上，要求读取数据 R 前必须先对 R 加 S 锁，直到事务结束才释放
{% endhint %}

> 三级封锁协议能保证不丢失修改、可重复读、不读脏数据

## 9.4 活锁和死锁 <a href="#9.4-livelocks-and-deadlocks" id="9.4-livelocks-and-deadlocks"></a>

### 9.4.1 活锁 <a href="#9.4.1" id="9.4.1"></a>

一个事务 T 一直等待获取某个对象的锁，但是其它后来的事务一直先获取到锁，导致事务 T 一直等待，称为**活锁**

<mark style="background-color:red;">避免活锁的简单方法就是采用先来先服务的策略</mark>

### 9.4.2 死锁 <a href="#9.4.2" id="9.4.2"></a>

事务 $$T_1$$ 获取了锁 $$R_1$$，事务 $$T_2$$ 获取了锁 $$R_2$$，然后 $$T_1$$ 想获取锁 $$R_2$$，$$T_2$$ 想获取锁 $$R_1$$，导致两个事务一直不能结束形成**死锁**

一、死锁的预防

* 一次封锁法：事务一次性将所有要是使用的数据全部加锁
* 顺序封锁法：预先对数据对象规定一个封锁顺序，所有事物都按这个顺序封锁

二、死锁的诊断

* 超时法：如果一个事物的等待时间超过了规定的时限，就认为发生了死锁
* 等待图法：并发子系统周期性的生成事务的等待图，并进行检测，如果发现图中出现回路，则说明出现死锁

三、死锁的解除

* 选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有锁，使其它事务得以继续运行下去
